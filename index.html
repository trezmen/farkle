<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Farkle Tracker</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #f6f7f9; color: #111; }
    header { background: #fff; padding: 14px 16px; border-bottom: 1px solid #e6e8ee; position: sticky; top: 0; z-index: 10; }
    header h1 { margin: 0; font-size: 18px; }
    main { padding: 16px; max-width: 920px; margin: 0 auto; }

    .card { background: #fff; border: 1px solid #e6e8ee; border-radius: 12px; padding: 14px; box-shadow: 0 1px 0 rgba(0,0,0,0.03); }
    .stack { display: grid; gap: 12px; }

    label { font-size: 12px; color: #444; }
    input[type="text"]{
      width: 100%;
      padding: 12px 12px;
      border: 1px solid #d7dbe6;
      border-radius: 10px;
      font-size: 16px;
      box-sizing: border-box;
      background: #fff;
    }

    button {
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid #d7dbe6;
      background: #fff;
      font-size: 16px;
      cursor: pointer;
      width: 100%;
    }
    button:disabled { opacity: 0.55; cursor: not-allowed; }

    .hidden { display: none !important; }

    /* Setup: number buttons */
    .numGrid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
    }
    .numBtn { padding: 10px 0; border-radius: 10px; font-size: 14px; }
    .numBtn.active { border-color: #111; box-shadow: 0 0 0 2px rgba(17,17,17,0.12); }

    /* Green buttons (Start Game + End Turn) */
    .success { background: #1b7f3a; color: #fff; border-color: #1b7f3a; }
    .danger { background: #b00020; color: #fff; border-color: #b00020; }
    .ghost { background: #fff; }

    /* Next roll active blue */
    .primaryBlue { background: #0b5fff; color: #fff; border-color: #0b5fff; }

    /* Setup layout */
    .setupActions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (min-width: 720px) { .setupActions { grid-template-columns: 1fr 1fr 1fr; } }

    .namesGrid { display: grid; gap: 10px; }
    @media (min-width: 720px) { .namesGrid { grid-template-columns: 1fr 1fr; } }

    .muted { color: #666; font-size: 12px; line-height: 1.4; }

    /* Game */
    .currentPlayerTop {
      font-size: 14px;
      font-weight: 650;
      margin: 0;
    }

    /* Options: forced two columns */
    .optionsTwoCol {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      align-items: start;
    }
    .optCol { display: grid; gap: 10px; }

    .opt {
      text-align: left;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid #d7dbe6;
      background: #fff;
      user-select: none;
    }
    .opt .title { font-weight: 650; font-size: 15px; }

    /* Highlight states (more obvious) */
    /* selected1 is now the old x2-look (used for first selection) */
    .opt.selected1 { border-color: #111; box-shadow: 0 0 0 2px rgba(17,17,17,0.18); background: #f0f2f7; }
    /* selected2 is stronger (used for x2) */
    .opt.selected2 { border-color: #111; box-shadow: 0 0 0 3px rgba(17,17,17,0.22); background: #e6eaf5; }

    /* Totals row */
    .totalsRow {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    .stat {
      border: 1px solid #e6e8ee;
      border-radius: 12px;
      padding: 12px;
      background: #fbfbfd;
    }
    .stat .k { font-size: 12px; color: #444; }
    .stat .v { font-size: 20px; font-weight: 700; margin-top: 6px; }

    .btnRow3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    @media (max-width: 420px) { .btnRow3 { grid-template-columns: 1fr; } }

    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 10px 8px; border-bottom: 1px solid #eef0f6; font-size: 14px; }
    th { font-size: 12px; color: #444; font-weight: 650; }
  </style>
</head>
<body>
  <header>
    <h1>Farkle Tracker</h1>
  </header>

  <main class="stack">
    <!-- SETUP -->
    <section id="setupView" class="card stack">
      <div class="stack">
        <div class="muted">Choose number of players (1–10). This order becomes the turn rotation.</div>
        <div id="numGrid" class="numGrid"></div>

        <div id="namesArea" class="namesGrid"></div>

        <div class="setupActions">
          <button id="startGameBtn" class="success" disabled>Start game</button>
          <button id="clearSetupBtn" class="ghost">Clear</button>
        </div>
      </div>
    </section>

    <!-- GAME -->
    <section id="gameView" class="card stack hidden">
      <p class="currentPlayerTop" id="currentPlayerLine">Current player: —</p>

      <div class="optionsTwoCol">
        <div class="optCol" id="leftOptions"></div>
        <div class="optCol" id="rightOptions"></div>
      </div>

      <div class="totalsRow">
        <div class="stat">
          <div class="k">Selected points</div>
          <div class="v" id="selectedPoints">0</div>
        </div>
        <div class="stat">
          <div class="k">Round total</div>
          <div class="v" id="roundTotal">0</div>
        </div>
        <div class="stat">
          <div class="k">Grand total</div>
          <div class="v" id="projectedGrand">0</div>
        </div>
      </div>

      <div class="btnRow3">
        <button id="nextRollBtn" disabled>Next roll</button>
        <button id="farkleBtn" class="danger">Farkle</button>
        <button id="endTurnBtn" class="success">End turn</button>
      </div>

      <div class="btnRow3">
        <button id="backBtn" class="ghost" disabled>Back</button>
        <button id="resetGameBtn" class="ghost">Reset game</button>
        <button id="backToSetupBtn" class="ghost">Setup Game</button>
      </div>

      <div class="stack">
        <h2 style="margin: 6px 0 0 0; font-size: 16px;">Scoreboard</h2>
        <div class="card" style="padding: 0;">
          <table>
            <thead>
              <tr><th>Player</th><th>Grand total</th></tr>
            </thead>
            <tbody id="scoreboardBody"></tbody>
          </table>
        </div>
      </div>
    </section>
  </main>

  <script>
    // ---------------------------
    // Options in EXACT order/labels you specified
    // ---------------------------
    const LEFT_COLUMN = [
      { id: "fives", label: "Fives", points: 50, mode: "cycle2" },
      { id: "t1", label: "Triple 1s", points: 300, mode: "toggle" },
      { id: "t2", label: "Triple 2s", points: 200, mode: "toggle" },
      { id: "t3", label: "Triple 3s", points: 300, mode: "toggle" },
      { id: "t4", label: "Triple 4s", points: 400, mode: "toggle" },
      { id: "t5", label: "Triple 5s", points: 500, mode: "toggle" },
      { id: "t6", label: "Triple 6s", points: 600, mode: "toggle" },
    ];

    const RIGHT_COLUMN = [
      { id: "ones", label: "Ones", points: 100, mode: "cycle2" },
      { id: "4kind", label: "Four-of-a-kind", points: 1000, displayPoints: "1k", mode: "toggle" },
      { id: "5kind", label: "Five-of-a-kind", points: 2000, mode: "toggle" },
      { id: "6kind", label: "Six-of-a-kind", points: 3000, mode: "toggle" },
      { id: "3pairs", label: "Three pairs", points: 1500, mode: "toggle" },
      { id: "quadpair", label: "Quad + Pair", points: 1500, mode: "toggle" },
      { id: "2trip", label: "Two Triplets", points: 2500, mode: "toggle" },
    ];

    const ALL_OPTIONS = [...LEFT_COLUMN, ...RIGHT_COLUMN];

    // ---------------------------
    // State
    // ---------------------------
    let selectedPlayerCount = 0;

    let players = []; // [{ name, total }]
    let currentPlayerIndex = 0;
    let roundTotal = 0;

    // Selection state for the CURRENT roll only:
    // - toggle options: 0 or 1
    // - cycle2 options (ones/fives): 0,1,2
    const selectionCounts = new Map(); // id -> count (0..2 or 0/1)

    // Back/Undo: store snapshots before any action
    const history = []; // stack of snapshots

    // ---------------------------
    // Elements
    // ---------------------------
    const setupView = document.getElementById("setupView");
    const gameView = document.getElementById("gameView");

    const numGrid = document.getElementById("numGrid");
    const namesArea = document.getElementById("namesArea");
    const startGameBtn = document.getElementById("startGameBtn");
    const clearSetupBtn = document.getElementById("clearSetupBtn");

    const currentPlayerLine = document.getElementById("currentPlayerLine");
    const leftOptionsEl = document.getElementById("leftOptions");
    const rightOptionsEl = document.getElementById("rightOptions");

    const selectedPointsEl = document.getElementById("selectedPoints");
    const roundTotalEl = document.getElementById("roundTotal");
    const projectedGrandEl = document.getElementById("projectedGrand");

    const nextRollBtn = document.getElementById("nextRollBtn");
    const farkleBtn = document.getElementById("farkleBtn");
    const endTurnBtn = document.getElementById("endTurnBtn");
    const backBtn = document.getElementById("backBtn");
    const resetGameBtn = document.getElementById("resetGameBtn");
    const backToSetupBtn = document.getElementById("backToSetupBtn");

    const scoreboardBody = document.getElementById("scoreboardBody");

    // ---------------------------
    // Setup UI
    // ---------------------------
    function renderNumButtons() {
      numGrid.innerHTML = "";
      for (let i = 1; i <= 10; i++) {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "numBtn";
        b.textContent = String(i);
        b.addEventListener("click", () => {
          selectedPlayerCount = i;
          highlightActiveNum(i);
          buildNameFields(i);
        });
        numGrid.appendChild(b);
      }
    }

    function highlightActiveNum(n) {
      [...numGrid.querySelectorAll("button")].forEach(btn => {
        btn.classList.toggle("active", btn.textContent === String(n));
      });
    }

    function clearSetupUI() {
      selectedPlayerCount = 0;
      highlightActiveNum(-1);
      namesArea.innerHTML = "";
      startGameBtn.disabled = true;
    }

    function buildNameFields(n) {
      namesArea.innerHTML = "";
      for (let i = 0; i < n; i++) {
        const wrap = document.createElement("div");

        const lab = document.createElement("label");
        lab.setAttribute("for", `pname_${i}`);
        lab.textContent = `Player ${i + 1} name`;

        const inp = document.createElement("input");
        inp.type = "text";
        inp.id = `pname_${i}`;
        inp.placeholder = `Player ${i + 1}`;
        inp.autocomplete = "off";

        // Helps mobile keyboards auto-capitalize names
        inp.setAttribute("autocapitalize", "words");
        inp.setAttribute("autocorrect", "on");

        inp.addEventListener("input", validateSetupReady);

        // Enter moves to next field; last field starts game (if ready)
        inp.addEventListener("keydown", (e) => {
          if (e.key !== "Enter") return;
          e.preventDefault();
          const next = document.getElementById(`pname_${i + 1}`);
          if (next) {
            next.focus();
            next.select?.();
            return;
          }
          validateSetupReady();
          if (!startGameBtn.disabled) startGame();
        });

        wrap.appendChild(lab);
        wrap.appendChild(inp);
        namesArea.appendChild(wrap);
      }
      validateSetupReady();
      const first = document.getElementById("pname_0");
      if (first) first.focus();
    }

    function validateSetupReady() {
      const inputs = namesArea.querySelectorAll("input[type='text']");
      if (!inputs.length) {
        startGameBtn.disabled = true;
        return;
      }
      let ok = true;
      inputs.forEach(inp => {
        if (!inp.value.trim()) ok = false;
      });
      startGameBtn.disabled = !ok;
    }

    // ---------------------------
    // Game UI: options
    // ---------------------------
    function initSelectionCounts() {
      selectionCounts.clear();
      for (const opt of ALL_OPTIONS) selectionCounts.set(opt.id, 0);
    }

    function formatOptionLabel(opt, count) {
      const pointsText = opt.displayPoints ?? String(opt.points);

      if (opt.mode === "cycle2") {
        if (count === 0) return `${opt.label} (${pointsText})`;
        if (count === 1) return `${opt.label} (${pointsText})`;
        return `${opt.label} (${pointsText}) x2`;
      }
      return `${opt.label} (${pointsText})`;
    }

    function getSelectedPoints() {
      let sum = 0;
      for (const opt of ALL_OPTIONS) {
        const c = selectionCounts.get(opt.id) || 0;
        if (opt.mode === "cycle2") sum += c * opt.points;
        else sum += (c ? opt.points : 0);
      }
      return sum;
    }

    function renderOptionButton(opt) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "opt";
      btn.dataset.id = opt.id;

      const title = document.createElement("div");
      title.className = "title";
      title.textContent = formatOptionLabel(opt, 0);
      btn.appendChild(title);

      btn.addEventListener("click", () => {
        const current = selectionCounts.get(opt.id) || 0;
        let next = current;

        if (opt.mode === "cycle2") {
          // off -> x1 -> x2 -> off
          next = (current + 1) % 3;
        } else {
          // toggle 0/1
          next = current ? 0 : 1;
        }

        selectionCounts.set(opt.id, next);
        updateSelectionsUI();
      });

      return btn;
    }

    function renderOptions() {
      leftOptionsEl.innerHTML = "";
      rightOptionsEl.innerHTML = "";

      for (const opt of LEFT_COLUMN) leftOptionsEl.appendChild(renderOptionButton(opt));
      for (const opt of RIGHT_COLUMN) rightOptionsEl.appendChild(renderOptionButton(opt));

      updateSelectionsUI();
    }

    function updateSelectionsUI() {
      const allButtons = [...leftOptionsEl.querySelectorAll(".opt"), ...rightOptionsEl.querySelectorAll(".opt")];

      for (const btn of allButtons) {
        const id = btn.dataset.id;
        const opt = ALL_OPTIONS.find(o => o.id === id);
        const count = selectionCounts.get(id) || 0;

        btn.querySelector(".title").textContent = formatOptionLabel(opt, count);

        btn.classList.remove("selected1", "selected2");

        if (opt.mode === "cycle2") {
          // More obvious: x1 uses the old x2 highlight; x2 uses stronger highlight
          if (count === 1) btn.classList.add("selected1");
          if (count === 2) btn.classList.add("selected2");
        } else {
          if (count === 1) btn.classList.add("selected1");
        }
      }

      const selectedPoints = getSelectedPoints();
      selectedPointsEl.textContent = String(selectedPoints);
      roundTotalEl.textContent = String(roundTotal);

      const currentGrand = players[currentPlayerIndex]?.total ?? 0;
      projectedGrandEl.textContent = String(currentGrand + roundTotal + selectedPoints);

      nextRollBtn.disabled = selectedPoints <= 0;

      // Next roll enabled styling (blue background, white text)
      nextRollBtn.classList.toggle("primaryBlue", !nextRollBtn.disabled);

      backBtn.disabled = history.length === 0;

      const name = players[currentPlayerIndex]?.name ?? "—";
      currentPlayerLine.textContent = `Current player: ${name}`;

      renderScoreboard();
    }

    // ---------------------------
    // Scoreboard
    // ---------------------------
    function renderScoreboard() {
      scoreboardBody.innerHTML = "";
      for (let i = 0; i < players.length; i++) {
        const tr = document.createElement("tr");
        const tdName = document.createElement("td");
        const tdScore = document.createElement("td");

        tdName.textContent = players[i].name + (i === currentPlayerIndex ? " (turn)" : "");
        tdScore.textContent = String(players[i].total);

        tr.appendChild(tdName);
        tr.appendChild(tdScore);
        scoreboardBody.appendChild(tr);
      }
    }

    // ---------------------------
    // History (Back button)
    // ---------------------------
    function snapshotState() {
      return {
        players: players.map(p => ({ name: p.name, total: p.total })),
        currentPlayerIndex,
        roundTotal,
        selectionCounts: new Map(selectionCounts),
      };
    }

    function restoreState(snap) {
      players = snap.players.map(p => ({ name: p.name, total: p.total }));
      currentPlayerIndex = snap.currentPlayerIndex;
      roundTotal = snap.roundTotal;
      selectionCounts.clear();
      for (const [k, v] of snap.selectionCounts.entries()) selectionCounts.set(k, v);
      updateSelectionsUI();
    }

    function pushHistory() {
      history.push(snapshotState());
      if (history.length > 50) history.shift();
      backBtn.disabled = history.length === 0;
    }

    function popHistory() {
      const snap = history.pop();
      if (!snap) return;
      restoreState(snap);
      backBtn.disabled = history.length === 0;
    }

    // ---------------------------
    // Game actions
    // ---------------------------
    function clearRollSelection() {
      for (const opt of ALL_OPTIONS) selectionCounts.set(opt.id, 0);
    }

    function advancePlayer() {
      currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
      roundTotal = 0;
      clearRollSelection();
    }

    function startGame() {
      const inputs = namesArea.querySelectorAll("input[type='text']");
      players = [];
      inputs.forEach(inp => players.push({ name: inp.value.trim(), total: 0 }));

      currentPlayerIndex = 0;
      roundTotal = 0;
      history.length = 0;

      initSelectionCounts();

      setupView.classList.add("hidden");
      gameView.classList.remove("hidden");

      renderOptions();
      updateSelectionsUI();
    }

    function onNextRoll() {
      const add = getSelectedPoints();
      if (add <= 0) return;
      pushHistory();
      roundTotal += add;
      clearRollSelection();
      updateSelectionsUI();
    }

    function onFarkle() {
      pushHistory();
      roundTotal = 0;
      clearRollSelection();
      advancePlayer();
      updateSelectionsUI();
    }

    function onEndTurn() {
      pushHistory();
      const bank = roundTotal + getSelectedPoints();
      players[currentPlayerIndex].total += bank;
      roundTotal = 0;
      clearRollSelection();
      advancePlayer();
      updateSelectionsUI();
    }

    // Reset game: wipe points but keep same players
    function resetPointsKeepPlayers() {
      if (!confirm("Reset all points for current players?")) return;
      history.length = 0;
      roundTotal = 0;
      clearRollSelection();
      for (const p of players) p.total = 0;
      updateSelectionsUI();
    }

    function setupGame() {
      if (!confirm("Go to setup? Current game will be lost.")) return;
      players = [];
      currentPlayerIndex = 0;
      roundTotal = 0;
      selectionCounts.clear();
      history.length = 0;

      gameView.classList.add("hidden");
      setupView.classList.remove("hidden");
      clearSetupUI();
    }

    // ---------------------------
    // Wire up
    // ---------------------------
    startGameBtn.addEventListener("click", startGame);
    clearSetupBtn.addEventListener("click", () => { clearSetupUI(); });

    nextRollBtn.addEventListener("click", onNextRoll);
    farkleBtn.addEventListener("click", onFarkle);
    endTurnBtn.addEventListener("click", onEndTurn);
    backBtn.addEventListener("click", popHistory);

    resetGameBtn.addEventListener("click", resetPointsKeepPlayers);
    backToSetupBtn.addEventListener("click", setupGame);

    // Init
    renderNumButtons();
    clearSetupUI();
  </script>
</body>
</html>
