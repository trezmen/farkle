<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Farkle Tracker</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #f6f7f9; color: #111; }

    /* Header no longer sticks */
    header { background: #fff; padding: 14px 16px; border-bottom: 1px solid #e6e8ee; position: static; }
    header h1 { margin: 0; font-size: 18px; }

    main { padding: 16px; max-width: 920px; margin: 0 auto; }

    .card { background: #fff; border: 1px solid #e6e8ee; border-radius: 12px; padding: 14px; box-shadow: 0 1px 0 rgba(0,0,0,0.03); }
    .stack { display: grid; gap: 12px; }

    label { font-size: 12px; color: #444; }
    input[type="text"]{
      width: 100%;
      padding: 12px 12px;
      border: 1px solid #d7dbe6;
      border-radius: 10px;
      font-size: 16px;
      box-sizing: border-box;
      background: #fff;
    }

    button {
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid #d7dbe6;
      background: #fff;
      font-size: 16px;
      cursor: pointer;
      width: 100%;
    }
    button:disabled { opacity: 0.55; cursor: not-allowed; }

    .hidden { display: none !important; }

    /* Setup: number buttons */
    .numGrid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
    }
    .numBtn { padding: 10px 0; border-radius: 10px; font-size: 14px; }
    .numBtn.active { border-color: #111; box-shadow: 0 0 0 2px rgba(17,17,17,0.12); }

    /* Green buttons (Start Game + End Turn) */
    .success { background: #1b7f3a; color: #fff; border-color: #1b7f3a; }
    .danger { background: #b00020; color: #fff; border-color: #b00020; }
    .ghost { background: #fff; }

    /* Next roll active blue */
    .primaryBlue { background: #0b5fff; color: #fff; border-color: #0b5fff; }

    /* Setup layout */
    .setupActions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (min-width: 720px) { .setupActions { grid-template-columns: 1fr 1fr 1fr; } }

    .namesGrid { display: grid; gap: 10px; }
    @media (min-width: 720px) { .namesGrid { grid-template-columns: 1fr 1fr; } }

    .muted { color: #666; font-size: 12px; line-height: 1.4; }

    /* Game */
    .currentPlayerTop {
      font-size: 14px;
      font-weight: 650;
      margin: 0;
    }

    /* Options: forced two columns */
    .optionsTwoCol {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      align-items: start;
    }
    .optCol { display: grid; gap: 10px; }

    .opt {
      text-align: left;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid #d7dbe6;
      background: #fff;
      user-select: none;
    }
    .opt .title { font-weight: 650; font-size: 15px; }

    /* Highlight states (more obvious) */
    .opt.selected1 { border-color: #111; box-shadow: 0 0 0 2px rgba(17,17,17,0.18); background: #f0f2f7; }
    .opt.selected2 { border-color: #111; box-shadow: 0 0 0 3px rgba(17,17,17,0.22); background: #e6eaf5; }

    /* Totals row */
    .totalsRow {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    .stat {
      border: 1px solid #e6e8ee;
      border-radius: 12px;
      padding: 12px;
      background: #fbfbfd;
    }
    .stat .k { font-size: 12px; color: #444; }
    .stat .v { font-size: 20px; font-weight: 700; margin-top: 6px; }

    /* Gold highlight for 10k+ */
    .gold {
      background: #fff3b0 !important;
      border-color: #e6c200 !important;
    }

    .btnRow3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    @media (max-width: 420px) { .btnRow3 { grid-template-columns: 1fr; } }

    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 10px 8px; border-bottom: 1px solid #eef0f6; font-size: 14px; }
    th { font-size: 12px; color: #444; font-weight: 650; }

    /* Gold row for 10k+ in scoreboard */
    tr.goldRow td { background: #fff3b0; }
  </style>
</head>
<body>
  <header>
    <h1>Farkle Tracker</h1>
  </header>

  <main class="stack">
    <!-- SETUP -->
    <section id="setupView" class="card stack">
      <div class="stack">
        <div class="muted">Choose number of players (1â€“10). This order becomes the turn rotation.</div>
        <div id="numGrid" class="numGrid"></div>

        <div id="namesArea" class="namesGrid"></div>

        <div class="setupActions">
          <button id="startGameBtn" class="success" disabled>Start game</button>
          <button id="clearSetupBtn" class="ghost">Clear</button>
        </div>
      </div>
    </section>

    <!-- GAME -->
    <section id="gameView" class="card stack hidden">
      <p class="currentPlayerTop" id="currentPlayerLine">Current player: â€”</p>

      <div class="optionsTwoCol">
        <div class="optCol" id="leftOptions"></div>
        <div class="optCol" id="rightOptions"></div>
      </div>

      <div class="totalsRow">
        <div class="stat">
          <div class="k">Selected points</div>
          <div class="v" id="selectedPoints">0</div>
        </div>
        <div class="stat">
          <div class="k">Round total</div>
          <div class="v" id="roundTotal">0</div>
        </div>
        <div class="stat" id="grandTotalStat">
          <div class="k">Grand total</div>
          <div class="v" id="projectedGrand">0</div>
        </div>
      </div>

      <div class="btnRow3">
        <button id="nextRollBtn" disabled>Next roll</button>
        <button id="farkleBtn" class="danger">Farkle</button>
        <button id="endTurnBtn" class="success">End turn</button>
      </div>

      <div class="btnRow3">
        <button id="backBtn" class="ghost" disabled>Back</button>
        <button id="resetGameBtn" class="ghost">Reset game</button>
        <button id="backToSetupBtn" class="ghost">Setup Game</button>
      </div>

      <div class="stack">
        <div class="card" style="padding: 0;">
          <table>
            <thead>
              <tr><th>Player</th><th>Grand total</th></tr>
            </thead>
            <tbody id="scoreboardBody"></tbody>
          </table>
        </div>
      </div>
    </section>
  </main>

  <script>
    // ---------------------------
    // Options (order/labels)
    // ---------------------------
    const LEFT_COLUMN = [
      { id: "fives", label: "Fives", points: 50, mode: "cycle2" },
      { id: "t1", label: "Triple 1s", points: 300, mode: "toggle" },
      { id: "t2", label: "Triple 2s", points: 200, mode: "toggle" },
      { id: "t3", label: "Triple 3s", points: 300, mode: "toggle" },
      { id: "t4", label: "Triple 4s", points: 400, mode: "toggle" },
      { id: "t5", label: "Triple 5s", points: 500, mode: "toggle" },
      { id: "t6", label: "Triple 6s", points: 600, mode: "toggle" },
    ];

    const RIGHT_COLUMN = [
      { id: "ones", label: "Ones", points: 100, mode: "cycle2" },
      { id: "4kind", label: "Four-of-a-kind", points: 1000, displayPoints: "1k", mode: "toggle" },
      { id: "5kind", label: "Five-of-a-kind", points: 2000, displayPoints: "2k", mode: "toggle" },
      { id: "6kind", label: "Six-of-a-kind", points: 3000, mode: "toggle" },
      { id: "3pairs", label: "3 Pair / Straight", points: 1500, displayPoints: "1.5k", mode: "toggle" },
      { id: "quadpair", label: "Quad + Pair", points: 1500, mode: "toggle" },
      { id: "2trip", label: "Two Triplets", points: 2500, mode: "toggle" },
    ];

    const ALL_OPTIONS = [...LEFT_COLUMN, ...RIGHT_COLUMN];

    // ---------------------------
    // State
    // ---------------------------
    let selectedPlayerCount = 0;

    let players = []; // [{ name, total }]
    let currentPlayerIndex = 0;
    let roundTotal = 0;

    // selectionCounts: id -> count (0..2 for cycle2, 0/1 for toggle)
    const selectionCounts = new Map();

    // Back/Undo history
    const history = [];

    // ---------------------------
    // Elements
    // ---------------------------
    const setupView = document.getElementById("setupView");
    const gameView = document.getElementById("gameView");

    const numGrid = document.getElementById("numGrid");
    const namesArea = document.getElementById("namesArea");
    const startGameBtn = document.getElementById("startGameBtn");
    const clearSetupBtn = document.getElementById("clearSetupBtn");

    const currentPlayerLine = document.getElementById("currentPlayerLine");
    const leftOptionsEl = document.getElementById("leftOptions");
    const rightOptionsEl = document.getElementById("rightOptions");

    const selectedPointsEl = document.getElementById("selectedPoints");
    const roundTotalEl = document.getElementById("roundTotal");
    const projectedGrandEl = document.getElementById("projectedGrand");
    const grandTotalStatEl = document.getElementById("grandTotalStat");

    const nextRollBtn = document.getElementById("nextRollBtn");
    const farkleBtn = document.getElementById("farkleBtn");
    const endTurnBtn = document.getElementById("endTurnBtn");
    const backBtn = document.getElementById("backBtn");
    const resetGameBtn = document.getElementById("resetGameBtn");
    const backToSetupBtn = document.getElementById("backToSetupBtn");

    const scoreboardBody = document.getElementById("scoreboardBody");

    // ---------------------------
    // Name capitalization helper
    // ---------------------------
    function toTitleCaseWords(s) {
      return s
        .trim()
        .split(/\s+/)
        .filter(Boolean)
        .map(w => {
          const lower = w.toLowerCase();
          return lower.charAt(0).toUpperCase() + lower.slice(1);
        })
        .join(" ");
    }

    // ---------------------------
    // Setup UI
    // ---------------------------
    function renderNumButtons() {
      numGrid.innerHTML = "";
      for (let i = 1; i <= 10; i++) {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "numBtn";
        b.textContent = String(i);
        b.addEventListener("click", () => {
          selectedPlayerCount = i;
          highlightActiveNum(i);
          buildNameFields(i);
        });
        numGrid.appendChild(b);
      }
    }

    function highlightActiveNum(n) {
      [...numGrid.querySelectorAll("button")].forEach(btn => {
        btn.classList.toggle("active", btn.textContent === String(n));
      });
    }

    function clearSetupUI() {
      selectedPlayerCount = 0;
      highlightActiveNum(-1);
      namesArea.innerHTML = "";
      startGameBtn.disabled = true;
    }

    function buildNameFields(n) {
      namesArea.innerHTML = "";
      for (let i = 0; i < n; i++) {
        const wrap = document.createElement("div");

        const lab = document.createElement("label");
        lab.setAttribute("for", `pname_${i}`);
        lab.textContent = `Player ${i + 1} name`;

        const inp = document.createElement("input");
        inp.type = "text";
        inp.id = `pname_${i}`;
        inp.placeholder = `Player ${i + 1}`;
        inp.autocomplete = "off";

        inp.setAttribute("autocapitalize", "words");
        inp.setAttribute("autocorrect", "on");
        inp.setAttribute("enterkeyhint", i === n - 1 ? "done" : "next");
        inp.spellcheck = true;

        inp.addEventListener("input", validateSetupReady);

        inp.addEventListener("blur", () => {
          const v = inp.value;
          const capped = toTitleCaseWords(v);
          if (capped !== v) inp.value = capped;
          validateSetupReady();
        });

        inp.addEventListener("keydown", (e) => {
          if (e.key !== "Enter") return;
          e.preventDefault();

          inp.value = toTitleCaseWords(inp.value);
          validateSetupReady();

          const next = document.getElementById(`pname_${i + 1}`);
          if (next) {
            next.focus();
            return;
          }
          if (!startGameBtn.disabled) startGame();
        });

        wrap.appendChild(lab);
        wrap.appendChild(inp);
        namesArea.appendChild(wrap);
      }
      validateSetupReady();
      const first = document.getElementById("pname_0");
      if (first) first.focus();
    }

    function validateSetupReady() {
      const inputs = namesArea.querySelectorAll("input[type='text']");
      if (!inputs.length) {
        startGameBtn.disabled = true;
        return;
      }
      let ok = true;
      inputs.forEach(inp => {
        if (!inp.value.trim()) ok = false;
      });
      startGameBtn.disabled = !ok;
    }

    // ---------------------------
    // Game UI: options
    // ---------------------------
    function initSelectionCounts() {
      selectionCounts.clear();
      for (const opt of ALL_OPTIONS) selectionCounts.set(opt.id, 0);
    }

    function formatOptionHTML(opt, count) {
      const pointsText = opt.displayPoints ?? String(opt.points);

      if (opt.mode === "cycle2") {
        if (count === 2) return `${opt.label} (${pointsText}) <strong>x2</strong>`;
        return `${opt.label} (${pointsText})`;
      }
      return `${opt.label} (${pointsText})`;
    }

    function getSelectedPoints() {
      let sum = 0;
      for (const opt of ALL_OPTIONS) {
        const c = selectionCounts.get(opt.id) || 0;
        if (opt.mode === "cycle2") sum += c * opt.points;
        else sum += (c ? opt.points : 0);
      }
      return sum;
    }

    function renderOptionButton(opt) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "opt";
      btn.dataset.id = opt.id;

      const title = document.createElement("div");
      title.className = "title";
      title.innerHTML = formatOptionHTML(opt, 0);
      btn.appendChild(title);

      btn.addEventListener("click", () => {
        const current = selectionCounts.get(opt.id) || 0;
        let next = current;

        if (opt.mode === "cycle2") next = (current + 1) % 3; // off -> x1 -> x2 -> off
        else next = current ? 0 : 1; // toggle

        selectionCounts.set(opt.id, next);
        updateSelectionsUI();
      });

      return btn;
    }

    function renderOptions() {
      leftOptionsEl.innerHTML = "";
      rightOptionsEl.innerHTML = "";

      for (const opt of LEFT_COLUMN) leftOptionsEl.appendChild(renderOptionButton(opt));
      for (const opt of RIGHT_COLUMN) rightOptionsEl.appendChild(renderOptionButton(opt));

      updateSelectionsUI();
    }

    function updateSelectionsUI() {
      const allButtons = [...leftOptionsEl.querySelectorAll(".opt"), ...rightOptionsEl.querySelectorAll(".opt")];

      for (const btn of allButtons) {
        const id = btn.dataset.id;
        const opt = ALL_OPTIONS.find(o => o.id === id);
        const count = selectionCounts.get(id) || 0;

        btn.querySelector(".title").innerHTML = formatOptionHTML(opt, count);

        btn.classList.remove("selected1", "selected2");
        if (opt.mode === "cycle2") {
          if (count === 1) btn.classList.add("selected1");
          if (count === 2) btn.classList.add("selected2");
        } else {
          if (count === 1) btn.classList.add("selected1");
        }
      }

      const selectedPoints = getSelectedPoints();
      selectedPointsEl.textContent = String(selectedPoints);
      roundTotalEl.textContent = String(roundTotal);

      const currentGrand = players[currentPlayerIndex]?.total ?? 0;
      const projectedGrand = currentGrand + roundTotal + selectedPoints;
      projectedGrandEl.textContent = String(projectedGrand);

      // Gold background for 10k+ in the "Grand total" box
      grandTotalStatEl.classList.toggle("gold", projectedGrand >= 10000);

      nextRollBtn.disabled = selectedPoints <= 0;
      nextRollBtn.classList.toggle("primaryBlue", !nextRollBtn.disabled);

      backBtn.disabled = history.length === 0;

      const name = players[currentPlayerIndex]?.name ?? "â€”";
      currentPlayerLine.textContent = `Current player: ${name}`;

      renderScoreboard();
    }

    // ---------------------------
    // Scoreboard with rank emojis (ðŸ¥‡ðŸ¥ˆðŸ¥‰) and tie handling (1,1,3)
    // No emoji shown for players with 0 points
    // ---------------------------
    function computeRanksByTotal(playersArr) {
      const totals = playersArr.map(p => p.total);
      const uniqueTotalsDesc = [...new Set(totals)].sort((a, b) => b - a);

      const rankByTotal = new Map();
      for (const t of uniqueTotalsDesc) {
        const higherCount = playersArr.filter(p => p.total > t).length;
        rankByTotal.set(t, higherCount + 1);
      }
      return rankByTotal;
    }

    function rankEmoji(rank) {
      if (rank === 1) return "ðŸ¥‡";
      if (rank === 2) return "ðŸ¥ˆ";
      if (rank === 3) return "ðŸ¥‰";
      return "";
    }

    function renderScoreboard() {
      scoreboardBody.innerHTML = "";
      const rankByTotal = computeRanksByTotal(players);

      for (let i = 0; i < players.length; i++) {
        const tr = document.createElement("tr");
        const tdName = document.createElement("td");
        const tdScore = document.createElement("td");

        const total = players[i].total;
        const rank = rankByTotal.get(total) ?? 0;

        // Row gold for 10k+
        tr.classList.toggle("goldRow", total >= 10000);

        const emoji =
          total > 0 && rank >= 1 && rank <= 3 ? " " + rankEmoji(rank) : "";

        const turnText = i === currentPlayerIndex ? " (turn)" : "";

        tdName.textContent = `${players[i].name}${emoji}${turnText}`;
        tdScore.textContent = String(total);

        tr.appendChild(tdName);
        tr.appendChild(tdScore);
        scoreboardBody.appendChild(tr);
      }
    }

    // ---------------------------
    // History (Back button)
    // ---------------------------
    function snapshotState() {
      return {
        players: players.map(p => ({ name: p.name, total: p.total })),
        currentPlayerIndex,
        roundTotal,
        selectionCounts: new Map(selectionCounts),
      };
    }

    function restoreState(snap) {
      players = snap.players.map(p => ({ name: p.name, total: p.total }));
      currentPlayerIndex = snap.currentPlayerIndex;
      roundTotal = snap.roundTotal;
      selectionCounts.clear();
      for (const [k, v] of snap.selectionCounts.entries()) selectionCounts.set(k, v);
      updateSelectionsUI();
    }

    function pushHistory() {
      history.push(snapshotState());
      if (history.length > 50) history.shift();
      backBtn.disabled = history.length === 0;
    }

    function popHistory() {
      const snap = history.pop();
      if (!snap) return;
      restoreState(snap);
      backBtn.disabled = history.length === 0;
    }

    // ---------------------------
    // Game actions
    // ---------------------------
    function clearRollSelection() {
      for (const opt of ALL_OPTIONS) selectionCounts.set(opt.id, 0);
    }

    function advancePlayer() {
      currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
      roundTotal = 0;
      clearRollSelection();
    }

    function startGame() {
      const inputs = namesArea.querySelectorAll("input[type='text']");
      players = [];
      inputs.forEach(inp => {
        const name = toTitleCaseWords(inp.value);
        inp.value = name;
        players.push({ name, total: 0 });
      });

      currentPlayerIndex = 0;
      roundTotal = 0;
      history.length = 0;

      initSelectionCounts();

      setupView.classList.add("hidden");
      gameView.classList.remove("hidden");

      renderOptions();
      updateSelectionsUI();
    }

    function onNextRoll() {
      const add = getSelectedPoints();
      if (add <= 0) return;
      pushHistory();
      roundTotal += add;
      clearRollSelection();
      updateSelectionsUI();
    }

    function onFarkle() {
      pushHistory();
      roundTotal = 0;
      clearRollSelection();
      advancePlayer();
      updateSelectionsUI();
    }

    function onEndTurn() {
      pushHistory();
      const bank = roundTotal + getSelectedPoints();
      players[currentPlayerIndex].total += bank;
      roundTotal = 0;
      clearRollSelection();
      advancePlayer();
      updateSelectionsUI();
    }

    // Reset game: wipe points but keep same players
    function resetPointsKeepPlayers() {
      if (!confirm("Reset all points for current players?")) return;
      history.length = 0;
      roundTotal = 0;
      clearRollSelection();
      for (const p of players) p.total = 0;
      updateSelectionsUI();
    }

    function setupGame() {
      if (!confirm("Go to setup? Current game will be lost.")) return;
      players = [];
      currentPlayerIndex = 0;
      roundTotal = 0;
      selectionCounts.clear();
      history.length = 0;

      gameView.classList.add("hidden");
      setupView.classList.remove("hidden");
      clearSetupUI();
    }

    // ---------------------------
    // Wire up
    // ---------------------------
    startGameBtn.addEventListener("click", startGame);
    clearSetupBtn.addEventListener("click", () => { clearSetupUI(); });

    nextRollBtn.addEventListener("click", onNextRoll);
    farkleBtn.addEventListener("click", onFarkle);
    endTurnBtn.addEventListener("click", onEndTurn);
    backBtn.addEventListener("click", popHistory);

    resetGameBtn.addEventListener("click", resetPointsKeepPlayers);
    backToSetupBtn.addEventListener("click", setupGame);

    // Init
    renderNumButtons();
    clearSetupUI();
  </script>
</body>
</html>
